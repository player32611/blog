# C++基础

::: danger 警告
该页面尚未完工!
:::

## 目录

[[toc]]

## 头文件

::: tip 注意

在 C 语言中头文件的扩展名是`.h`，但是 C++中的用法发生了一些变化，对老式 C 的头文件保留了扩展名`.h`，但是 C++自己的文件没有扩展名了。

有些 C 的头文件被转换成 C++头文件，这些文件名被重命名，去掉了`.h`扩展名，并在文件名的前面加上了前缀`c`(表示来自 C 语言)。有时头文件的 C 语言版本和 C++版本相同，而有时候，新版本做了一些修改。

| 头文件类型  |         约定         |      实例      |                    说明                    |
| :---------: | :------------------: | :------------: | :----------------------------------------: |
| C++旧式风格 |      以`.h`结尾      | `<iostream.h>` | C++程序可以使用，一些新的 IDE 可能不再支持 |
| C 旧式风格  |      以`.h`结尾      |   `<math.h>`   |             C、C++程序可以使用             |
| C++新式风格 |      没有扩展名      |  `<iostream>`  |    C++程序可以使用，使用 namespace std     |
| 转换后的 C  | 加上前缀，没有扩展名 |   `<cmath>`    |   C++程序可以使用，可能包含不是 C 的特性   |

:::

## 命名空间

在 C++中，变量、函数和类都是大量存在的，这些变量、函数和类的名称如果都存在于全局作用域中，可能会导致很多冲突，使用**命名空间**的目的是对标识符的名称进行隔离，以避免命名冲突或名字污染，`namespace`关键字的出现就是针对这种问题的。

`std`是 C++标准库的命名空间名，C++将标准库的定义实现都放到这个命名空间中，当我们需要使用标准库中的内容时，就需要加上：`using namespace std;`当有了这句代码的时候，表示命名空间`std`中信息都是可见和可用的，比如：`cin`、`cout`、`endl`等。

命名空间也是根据需要自己可以定义的。

代码中的`std::cout`的意思就是使用`std`命名空间中的`cout`。

::: warning 注意

采用`std::cout`这种写法，如果频繁使用，在算法竞赛中比较麻烦，耽搁时间。

但是在企业中做软件开发基本上都这样写的，这样写更好的避免名字冲突的问题。

:::

## 数据类型、变量与常量

### 各类型取值范围

|         类型         |                 取值范围                 |    速记最小值     |     速记最大值      |
| :------------------: | :--------------------------------------: | :---------------: | :-----------------: |
|        `char`        |                 -128~127                 |  `CHAR_MIN` -2^7  |  `CHAR_MAX` 2^7-1   |
|   `unsigned char`    |                  0~255                   |        `0`        |  `UCHAR_MAX` 2^8-1  |
|       `short`        |               -32768~32767               | `SHRT_MIN` -2^15  |  `SHRT_MAX` 2^15-1  |
|   `unsigned short`   |                 0~65535                  |        `0`        | `USHRT_MAX` 2^16-1  |
|        `int`         |          -2147483648~2147483647          |  `INT_MIN` -2^31  |  `INT_MAX` 2^31-1   |
|    `unsigned int`    |               0~4294967295               |        `0`        |  `UINT_MAX` 2^32-1  |
|        `long`        | -9223372036854775808~9223372036854775807 | `LONG_MIN` -2^31  |  `LONG_MAX` 2^31-1  |
|   `unsigned long`    |          0~18446744073709551615          |        `0`        | `ULONG_MAX` 2^32-1  |
|     `long long`      | -9223372036854775808~9223372036854775807 | `LLONG_MIN` -2^63 | `LLONG_MAX` 2^63-1  |
| `unsigned long long` |          0~18446744073709551615          |        `0`        | `ULLONG_MAX` 2^64-1 |

为了代码的可移植性，和方便记忆，需要知道某种整数类型的极限值时，经常使用这些速记的符号，`limits.h`文件中说明了整型类型的取值范围。(C++中头文件的名字是`<climits>`)

`float.h`这个头文件中说明浮点型类型的取值范围。(C++中头文件的名字是`<cfloat>`)

### typedef

在 C++中有一个关键字是和类型有关的，是用来给类型重命名的。当有一个类型比较复杂的时候，可以简化类型。`typedef`在竞赛中经常使用，可以提升编码速度。`typedef`使用的基本语法形式：

```c++
typedef <old_type> <new_type>;
```

比如：

```c++
typedef unsigned int ui;
typedef long long ll;
typedef unsigned long long ull;
```

上面代码的意思是将`unsigned int`重命名为`ui`，使用`ui`创建的变量和使用`unsigned int`是一样的，其它几个也是一样的道理。

### 全局变量与局部变量

- **全局变量**：在大括号外部定义的变量就是全局变量

- **局部变量**：在大括号内部定义的变量就是局部变量

当局部变量与全局变量同名的时候，局部变量优先使用。

::: tip 提示

如果想要使用全局变量，必须加上`::`

:::

::: warning 注意

全局变量通常在定义时就被初始化，如果没有明确指定初始值，它们通常会被初始化为 0

局部变量通常不会自动初始化。它们需要在使用之前明确地赋值或初始化。如果没有初始化，它们的值将是未定义的。

:::

::: tip 小提示

如果一个题目可以使用全局变量，又可以使用局部变量，那怎么选择呢？

**如果是在竞赛中：**

能使用全局变量，一般会直接使用全局变量，这样的好处是：

1.变量不需要初始化，因为默认会初始化为 0，这样写会比较块

2.很多时候，会避免传参，因为全局变量到处都可以使用

所以在竞赛中其实哪种方便就使用哪种，全局变量的使用很常见。

但是在企业里软件开发的工程实践中一般建议：能使用局部变量的，尽量减少使用全局变量，因为企业级的开发，代码量比较大，全局变量在任意地方都可以使用，这样就变得不可控了。

:::

### 常量

常量就是不能被改变的值，通常我们会使用三种常量：

- 字面常量

- `#define`定义的常量

- `const`定义的常量

```c++
#define 变量名 内容
```

使用`#define`定义常量的时候是不关注类型的，只关注常量的名字叫啥，常量的值是啥，编译在处理这种常量的时候就是直接替换，在出现常量名字的地方，通通替换成常量的内容。

::: tip 提示

习惯上，常量的名字一般会写成大写，而普通变量的名字不会全大写。

:::

## 输入输出

### getchar()

`getchar()`是属于 C 语言的库函数，C++是兼容 C 语言的，所以 C++中只要正确包含头文件也可以正常使用这个函数。

`getchar()`函数返回用户从键盘输入的一个字符，使用时不带有任何参数，函数原型如下：

```c++
int getchar(void);
```

程序运行到这个命令就会暂停，等待用户从键盘输入，等同于使用`cin`或`scanf()`方法读取一个字符。

它的原型定义在头文件`<cstdio>`。

::: tip 提示

`getchar()`不会忽略起首的空白字符，总是返回当前读取的第一个字符，无论是否为空格。

如果读取失败，返回常量`EOF`，由于`EOF`通常是 -1，所以返回值的类型要设为`int`，而不是`char`。

如何让`getchar()`函数读取失败，返回 -1 呢？其实需要在输入字符之前，直接按`Ctrl+z`就可以。

:::

### putchar()

`getchar()`通常和`putchar()`配合使用。`putchar()`函数原型如下：

```c++
int putchar(int ch);
```

`putchar()`函数将它的参数字符输出到屏幕，它的原型定义在头文件`<cstdio>`。

操作成功时，`putchar()`返回输出的字符，否则返回常量`EOF`。

### printf()

`printf()`函数函数原型如下：

```c++
int printf(const char *format, ...);
```

`printf()`的作用是将参数文本输出到屏幕，并可以定制输出文本的格式。

`printf()`不会在行尾自动添加换行符，运行结束后，光标就停留在输出结束的地方，不会自动换行。需使用换行符`\n`进行手动换行。

```c++
#include <cstdio>
int main(){
    printf("hello world\n");
}
```

`printf()`可以在输出文本中**指定占位符**，就是这个位置可以用其它值代入。

```c++
#include <cstdio>
int main(){
    printf("There are %d apples\n", 3);
}
```

上面示例中，`There are %d apples`是输出文本，里面的`%d`就是**占位符**。

占位符的第一个字符一律为百分号`%`，第二个字符表示占位符的类型，常见的占位符如下：

|  占位符  |                  介绍                   |
| :------: | :-------------------------------------: |
|  **%d**  |             **十进制整数**              |
| **%lld** |      **十进制 long long int 类型**      |
|  **%f**  | **小数(包含 float 类型和 double 类型)** |
| **%Lf**  |          **long double 类型**           |
|  **%c**  |                **字符**                 |
|  **%s**  |               **字符串**                |

`printf()`的第二个参数就是替换占位符的值。

输出文本里面可以使用**多个占位符**。

```c++
#include <cstdio>
int main() {
    printf("%s says it is %d o 'clock\n", "Lily", 21);
}
```

`printf()`参数与占位符是一一对应关系，如果有 n 个占位符，`printf()`的参数值就应该有 n+1 个。如果参数个数少于对应的占位符，`printf()`可能会输出内存中的任意值。

`printf()`可以定制占位符的输出格式。包括**限定占位符的最小宽度**，**限定小数的位数**

```c++
#include <cstdio>
int main() {
    printf("%5d\n", 123);
}
```

`%5d`表示这个占位符的宽度至少为 5 位。如果不满 5 位，对应的值的前面会添加空格。

::: tip 提示

输出的值默认是右对齐，即输出内容前面会有空格；如果希望改成右对齐，在输出内容后面添加空格，可以在占位符的 `%` 的后面插入一个 `-` 号。

:::

::: warning 注意

对于小数，这个限定符会限制所有数字的最小显示宽度。

:::

当希望限定小数的位数时，占位符可以写成`%.2f`，表示小数点后最多显示 2 位。

```c++
#include <cstdio>
int main() {
    printf("%.2f\n", 3.1415926);
}
```

这种写法可以与限定宽度占位符结合使用：

```c++
#include <cstdio>
int main() {
    printf("%6.2f\n", 3.1415926);
}
```

上面示例中，`%6.2f`表示输出字符串最小宽度为 6，小数位数为 2.

::: tip 提示

最小宽度和小数位数这两个限定值，都可以用 `*` 代替，通过`printf()`的参数指传入。

```c++
#include <cstdio>
int main() {
    printf("%*.*f\n", 6, 2, 3.1415926);
}
```

上面示例中，`%*.*f`的两个星号通过`printf()`的两个参数 6 和 2 传入。

:::

### scanf()

`scanf()`函数原型如下：

```c++
int scanf(const char *format, ...);
```

`scanf()`函数运用读取用户的键盘输入。程序运行到`scanf()`这个语句时，会停下来，等待用户从键盘输入。用户输入数据，按下回车键后，`scanf()`就会处理用户的输入，将其存入变量。

`scanf()`的语法跟`printf()`类似。

```c++
#include <cstdio>
int main() {
    int i = 0;
    scanf("%d", &i);
    printf("i = %d\n", i);
}
```

它的第一个参数是一个格式字符串，里面会放置占位符(与`printf()`的占位符基本一致)，告诉编译器如何解读用户的输入，需要提取的数据是什么类型。这是因为 C 语言的数据都是有类型的，`scanf()`必须提前知道用户输入的数据类型，才能处理数据。

它的其余参数就是存放用户输入的变量，格式字符串里面有多少个占位符，就有多少个变量。

::: warning 警告

`scanf()`函数中存储数据的变量前面必须加上`&`运算符(指针变量除外)，因为`scanf()`需要的是地址，必须将变量的地址取出来传给`scanf()`函数。

如果这里的变量是数组，那就不用加`&`运算符。

:::

::: warning 注意

`scanf()`函数的占位符后面一般不会加`\n`。

:::

下面是一次从键盘读取多个变量的例子：

```c++
#include <cstdio>
int main() {
    int a, b, c, d;
    scanf("%d%d%d%d", &a, &b, &c, &d);
    printf("a = %d, b = %d, c = %d, d = %d\n", a, b, c, d);
}
```

::: warning 注意

`scanf()`函数中指定的格式和程序输入的数据格式要严格的匹配，否则可能不能得到想要的值。

:::

读取多个变量时也可以读取不同类型的变量：

```c++
#include <cstdio>
int main() {
    int i = 0;
    int j = 0;
    float x = 0;
    float y = 0;
    scanf("%d%d%f%f", &i, &j, &x, &y);
    printf("i = %d, j = %d, x = %f, y = %f\n", i, j, x, y);
}
```

`scanf()` 处理数值占位符时，会自动过滤空白字符，包括空格、制表符、换行符等。所以，用户输入的数据之间，有一个或多个空格不影响`scanf()`解读数据。另外，用户使用回车键，将输入分成几行，也不影响解读。

`scanf()`常用的占位符如下，与`printf()`的占位符基本一致。

| 占位符  |                                      介绍                                      |
| :-----: | :----------------------------------------------------------------------------: |
| **%c**  |                                    **字符**                                    |
| **%d**  |                                    **整数**                                    |
| **%f**  |                              **float 类型浮点数**                              |
| **%lf** |                             **double 类型浮点数**                              |
| **%Lf** |                           **long double 类型浮点数**                           |
| **%s**  |                                   **字符串**                                   |
|   %[]   | 在方括号中指定一组匹配的字符(比如%[0-9])，遇到不在集合之中的字符，匹配将会停止 |

::: warning 注意

除了`%c`以外，都会自动忽略起首的空白字符。`%c`不忽略空白字符，总是返回当前第一个字符，无论该字符是否为空格。

如果要强制跳过字符前的空白字符，可以写成`scanf(" %c", &ch)`，即`%c`前加上一个空格，表示跳过零个或多个空白字符。

:::

::: details `scanf()`处理用户输入的原理

用户的输入先放入缓存，等到按下回车键后，按照占位符对缓存进行解读，解读用户输入时，会从上一次解读遗留的第一个字符开始，直到读完缓存，或者遇到第一个不符合条件的字符为止。

:::

`scanf()`的返回值是一个整数，表示成功读取的变量个数。如果没有读取任何项，或者匹配失败，则返回 0.如果在成功读取任何数据之前，发生了读取错误或者遇到读取到文件结尾，则返回常量 EOF (-1)。
