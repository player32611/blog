# 数据结构

::: danger 警告
该页面尚未完工!
:::

## 目录

[[toc]]

## 顺序表

### 线性表与顺序表的概念

线性表是 n 个具有相同特性的数据元素的有序序列。线性表的顺序存储就是顺序表。

### 顺序表的实现方式

按照数组的申请方式，有以下两种实现方式：

- 数组采用静态分配，此时的顺序表称为静态顺序表。就是直接向内存申请一大块连续的区域，然后将需要存放的数组放在这一大块连续的区域上。

- 数组采用动态分配，此时的顺序表称为动态顺序表。就是按照需要存放的数据的数量，合理的申请大小合适的空间来存放数据。

在算法竞赛中，我们主要关心的其实是时间开销，空间上是基本够用的。因此，定义一个超大的静态数组来解决问题是完全可以接受的。

### 创建顺序表

```c++
const int N = 1e6 + 10; // 定义静态数组的最大长度

int a[N], n; // 直接创建一个大数组来实现顺序表，n 表示当前有多少个元素。
```

### 插入元素

**尾插：在顺序表表尾的后面，插入一个新元素。**

时间复杂度：O(1)

```c++
// 尾插
void push_back(int x) {
	a[++n] = x;
}
```

::: tip 提示

约定：下标为 0 的位置，不存储有效数据。也就是说数据是从 a[1] 开始存储。

:::

**头插：在顺序表表头的前面，插入一个新元素。**

1: 将[1,n]内所有元素右移一位；

2: 新的元素放在表头；

3: 元素个数 +1。

```c++
// 头插
void push_front(int x) {
	for (int i = n; i >= 1; i--) {
		a[i + 1] = a[i];
	}
	a[1] = x;
	n++;
}
```

**任意位置插入：在位置 p 处，插入一个新的元素。**

1: 将[p,n]内所有元素右移一位；

2: 把新的元素放在 p 位置上；

3: 元素个数 +1。

时间复杂度：O(n)

```c++
// 任意位置插入
void insert(int p, int x) {
	for (int i = n; i >= p; i--)a[i + 1] = a[i];
	a[p] = x;
	n++;
}
```

### 删除元素

**尾删：删除顺序表的表尾元素。**

时间复杂度：O(1)

```c++
// 尾删
void pop_back() {
	n--;
}
```

**头删：删除顺序表的表头元素。**

1: 将[2,n]区间内的元素统一左移一位；

2: 元素个数 -1。

时间复杂度：O(n)

```c++
void pop_front() {
	for (int i = 2; i <= n; i++)a[i - 1] = a[i];
	n--;
}
```

**删除任意位置元素：删除位置 p 的元素。**

1: 将[p + 1,n]区间内的元素统一左移一位；

2: 元素个数 -1。

```c++
// 任意位置删除
void erase(int p) {
	for (int i = p + 1; i <= n; i++)a[i - 1] = a[i];
	n--;
}
```

### 查找元素

**按值查找：查找顺序表中数值 x 存储的位置**

策略：从前往后遍历整个顺序表，判断遍历到的元素是否等于 x。

时间复杂度：O(n)

```c++
// 按值查找
int find(int x) {
	for (int i = 1; i <= n; i++) {
		if (a[i] == x)return i;
	}
	return 0;
}
```

**按位查找：返回顺序表中第 p 位的元素**

时间复杂度：O(1)

```c++
// 按位查找
int at(int p) {
	return a[p];
}
```

### 修改元素

**修改元素：修改顺序表中第 p 位的元素为 x**

时间复杂度：O(1)

```c++
// 修改元素
void change(int p, int x) {
    a[p] = x;
}
```

### 清空顺序表

**清空顺序表：将顺序表置空**

时间复杂度：O(1)

```c++
// 清空顺序表
void clear() {
    n = 0;
}
```

::: warning 注意

要注意，我们直接实现的简单形式的时间复杂度是 O(1)。

但是，严谨的方式应该是 O(n)。

:::

### 封装静态顺序表

利用 C++中的结构体和类把我们实现的顺序表封装起来，就能简化操作，使代码的复用率大大提升。

```c++
class SQList {
	int a[N];
	int n;
public:
	// 尾插
	void push_back(int x) {
		a[++n] = x;
	}
	// 打印
	void print() {
		for (int i = 1; i <= n; i++)cout << a[i] << " ";
		cout << endl;
	}
	// ...
}
```

## 链表

### 链表的定义

- 链表：用**链式存储**实现的线性表。

- 带头链表：链表中第一个结点不存放数据元素，只存放下一个结点的指针。插入和删除操作更方便。

- 双向链表：每个结点除了存放数据元素外，还存放两个指针，分别指向该结点的前一个结点和后一个结点。方便找到前驱结点。

- 循环链表：最后一个结点的指针域指向头结点。从任意结点开始都能遍历整个链表。

链表的实现方式分为**动态实现**和**静态实现**两种。

- 动态实现是通过 new 申请结点，然后通过 delete 释放结点的形式构造链表。这种实现方式最能体现链表的特性；

- 静态实现是利用两个数组配合来模拟链表。运行速度很快，在算法竞赛中会经常使用到。

### 单链表的静态实现

要求：**两个足够大的数组**，**两个变量**

- 其中一个数组 elem 存储数据，充当数据域；

- 另一个数组 next 存储下一个结点的下标，充当指针域。

- 一个变量 h 标记头结点的下标；

- 另一个变量 id 标记新来结点的存储位置。

**定义、创建、初始化**

```c++
const int N = 1e5 + 10;

int e[N], ne[N], h, id;
```

**头插**

> 这是链表中最常用也是使用最多的操作。

1: 先把 x 放在一个格子里面；

2: x 的右指针指向哨兵位的后继

3: 哨兵位的右指针指向 x。

时间复杂度：O(1)

```c++
// 头插
void push_front(int x) {
	id++;
	e[id] = x;
	ne[id] = ne[h];
	ne[h] = id;
}
```

**遍历链表**

时间复杂度：O(n)

```c++
// 遍历链表
void print() {
	// 定义一个指针从头结点开始
	// 通过 ne 数组逐渐向后移动
	// 知道遇到空指针
	for (int i = ne[h]; i; i = ne[i])cout << e[i] << " ";
	cout << endl;
}
```

**按值查找**

解法一：遍历整个链表即可。时间复杂度：O(n)

解法二：如果存储的值数据范围不大，且无重复值，可以使用哈希表优化。时间复杂度：O(1)

::: code-group

```c++ [解法1]
// 遍历整个链表
int find(int x) {
	for (int i = ne[h]; i; i = ne[i])if (e[i] == x)return i;
	return 0;
}
```

```c++ [解法2]{2,7,12-14}
// 用哈希表优化
int mp[N]; // mp[i] 表示 i 这个元素存放的位置

void push_front(int x) {
	id++;
	e[id] = x;
	mp[x] = id;// 标记 x 存储的位置
	ne[id] = ne[h];
	ne[h] = id;
}

int find(int x) {
	return mp[x];
}
```

:::

**在任意（存储）位置之后插入元素**

时间复杂度：O(1)

```c++
void insert(int p, int x) {
	id++;
	e[id] = x;
	mp[x] = id;// 标记 x 存储的位置
	ne[id] = ne[p];
	ne[p] = id;
}
```

::: warning 警告注意

这里的 p 是存储位置，不是元素，也不是链表位置。

:::

**删除任意（存储）位置之后的元素**

时间复杂度：O(1)

```c++
void erase(int p) {
	if (ne[p]) { // 当 p 不是最后一个元素的时候
		mp[e[ne[p]]] = 0; // 把标记清空
		ne[p] = ne[ne[p]];
	}
}
```

### 双向链表的静态实现

要求：**三个足够大的数组**

- 第一个数组 `elem` 存储数据；

- 第二个数组 `prev` 存储前一个元素的存储下标；

- 第三个数组 `next` 存储下一个元素的存储下标。

```c++
const int N = 1e5 + 10;

int e[N], ne[N], pre[N], id, h;
```

**头插**

时间复杂度：O(1)

```c++
// 头插
void push_front(int x) {
	id++;
	e[id] = x;
	pre[id] = h;
	ne[id] = ne[h];
	pre[ne[h]] = id;
	ne[h] = id;
}
```

**遍历链表**

直接无视 `prev` 数组，与单链表的遍历方式一致。

```c++
// 遍历链表
void print() {
	for (int i = ne[h]; i; i = ne[i])cout << e[i] << " ";
	cout << endl;
}
```

**按值查找**

时间复杂度：O(1)

```c++{1,7,15-17}
int mp[N]; // mp[i] 表示 i 这个值存储的位置

// 头插
void push_front(int x) {
	id++;
	e[id] = x;
	mp[x] = id;
	pre[id] = h;
	ne[id] = ne[h];
	pre[ne[h]] = id;
	ne[h] = id;
}

// 按值查找
int find(int x) {
	return mp[x];
}
```

**在任意（存储）位置之后插入元素**

1: id++，标记新结点存储的位置；把新的元素存储下来；

2: 修改新结点的前驱指针，让其指向 p 位置；

3: 修改新结点的后继指针，让其指向 p 位置的下一个位置；

4: 修改 p 下一个位置的前驱指针，让其指向新的结点；

5: 修改 p 的后继指针，让其指向新的结点。

时间复杂度：O(1)

```c++
// 在任意位置之后插入元素
void insert(int p,int x) {
	id++;
	e[id] = x;
	mp[x] = id;
	pre[id] = p;
	ne[id] = ne[p];
	pre[ne[p]] = id;
	ne[p] = id;
}
```

**在任意（存储）位置之前插入元素**

1: id++，标记新结点存储的位置；

2: 修改新结点的前驱指针，让其指向 p 的前一个位置；

3: 修改新结点后继指针，让其指向 p 位置；

4: 修改 p 前一个位置的后继指针，让其指向新的结点；

5: 修改 p 的前驱指针，让其指向新的结点。

```c++
// 在任意位置之前插入元素
void insert_front(int p, int x) {
	id++;
	e[id] = x;
	mp[x] = id;
	pre[id] = pre[p];
	ne[id] = p;
	ne[pre[p]] = id;
	pre[p] = id;
}
```

**删除任意（存储）位置的元素**

- 让 p 的前驱结点的后继指针指向 p 的后继结点；

- 让 p 的后继结点的前驱指针指向 p 的前驱结点。

时间复杂度：O(1)

```c++
// 删除任意位置的元素
void erase(int p) {
	mp[e[p]] = 0; // 把标记清空
	ne[pre[p]] = ne[p];
	pre[ne[p]] = pre[p];
}
```

## 栈

栈是一种只允许**在一端**进行**插入和删除**操作的**线性表**。

- 进行数据插入或删除的一段称为**栈顶**，另一端称为**栈底**。。不含元素的栈称为**空栈**。

- **进栈**就是往栈中放入元素，**出栈**就是将元素弹出栈顶。

::: warning 注意

如果定义了一个栈结构，那么添加和删除元素只能在栈顶进行不能随意添加和删除元素。

:::

### 创建栈结构

1: 创建一个足够大的数组，充当栈结构；

2: 再定义一个变量 `n`，用来记录栈中元素的个数，同时还可以标记栈顶的位置。

```c++
const int N = 1e5 + 10;

int stk[N], n;
```

::: warning 注意

这里舍弃下标为 0 的位置，有效元素从 1 开始记录。

:::

### 进栈

时间复杂度：O(1)

```c++
// 进栈
void push(int x) {
	stk[++n] = x;
}
```

### 出栈

不用真的删除元素，只用将元素个数减 1，就相当于删除栈顶元素。

时间复杂度：O(1)

```c++
// 出栈
void pop() {
	n--;
}
```

### 获取栈顶元素

时间复杂度：O(1)

```c++
// 获取栈顶元素
int top() {
	return stk[n];
}
```

### 判断栈是否为空

时间复杂度：O(1)

```c++
// 判断栈是否为空
bool empty() {
	return n == 0;
}
```

### 获取栈中有效元素个数

时间复杂度：O(1)

```c++
// 获取栈中元素个数
int size() {
	return n;
}
```

## 队列

队列也是一种特殊的**线性表**，它只允许在表的**一端进行插入操作**，在**另一端进行删除操作**。

- 允许插入的一段称为**队尾**，允许删除的一端称为**队头**。

- 先进入队列的元素会先出队，故队列具有**先进先出（First In First Out）**的特性。

### 创建队列

**要求：**

- 一个足够大的数组充当队列；

- 一个变量 `h` 标记队头元素的前一个位置；

- 一个变量 `t` 标记队尾元素的位置。

```c++
const int N = 1e5 + 10;

int q[N], h, t;
```

::: warning 注意

这里舍弃下标为 0 的位置，有效元素从 1 开始记录。

:::

### 入队

时间复杂度：O(1)

```c++
// 入队
void push(int x) {
	q[++t] = x;
}
```

### 出队

时间复杂度：O(1)

```c++
// 出队
void pop() {
	h++;
}
```

### 获取队头元素

时间复杂度：O(1)

```c++
// 获取队头元素
int front() {
	return q[h + 1];
}
```

### 获取队尾元素

时间复杂度：O(1)

```c++
// 获取队尾元素
int back() {
	return q[t];
}
```

### 判断队列是否为空

时间复杂度：O(1)

```c++
bool empty() {
	return h == t;
}
```

### 获取队列中有效元素个数

时间复杂度：O(1)

```c++
int size() {
	return t - h;
}
```
