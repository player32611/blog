# 数据结构

::: danger 警告
该页面尚未完工!
:::

## 目录

[[toc]]

## 顺序表

### 线性表与顺序表的概念

线性表是 n 个具有相同特性的数据元素的有序序列。线性表的顺序存储就是顺序表。

### 顺序表的实现方式

按照数组的申请方式，有以下两种实现方式：

- 数组采用静态分配，此时的顺序表称为静态顺序表。就是直接向内存申请一大块连续的区域，然后将需要存放的数组放在这一大块连续的区域上。

- 数组采用动态分配，此时的顺序表称为动态顺序表。就是按照需要存放的数据的数量，合理的申请大小合适的空间来存放数据。

在算法竞赛中，我们主要关心的其实是时间开销，空间上是基本够用的。因此，定义一个超大的静态数组来解决问题是完全可以接受的。

### 创建顺序表

```c++
const int N = 1e6 + 10; // 定义静态数组的最大长度

int a[N], n; // 直接创建一个大数组来实现顺序表，n 表示当前有多少个元素。
```

### 插入元素

**尾插：在顺序表表尾的后面，插入一个新元素。**

时间复杂度：O(1)

```c++
// 尾插
void push_back(int x) {
	a[++n] = x;
}
```

::: tip 提示

约定：下标为 0 的位置，不存储有效数据。也就是说数据是从 a[1] 开始存储。

:::

**头插：在顺序表表头的前面，插入一个新元素。**

1: 将[1,n]内所有元素右移一位；

2: 新的元素放在表头；

3: 元素个数 +1。

```c++
// 头插
void push_front(int x) {
	for (int i = n; i >= 1; i--) {
		a[i + 1] = a[i];
	}
	a[1] = x;
	n++;
}
```

**任意位置插入：在位置 p 处，插入一个新的元素。**

1: 将[p,n]内所有元素右移一位；

2: 把新的元素放在 p 位置上；

3: 元素个数 +1。

时间复杂度：O(n)

```c++
// 任意位置插入
void insert(int p, int x) {
	for (int i = n; i >= p; i--)a[i + 1] = a[i];
	a[p] = x;
	n++;
}
```

### 删除元素

**尾删：删除顺序表的表尾元素。**

时间复杂度：O(1)

```c++
// 尾删
void pop_back() {
	n--;
}
```

**头删：删除顺序表的表头元素。**

1: 将[2,n]区间内的元素统一左移一位；

2: 元素个数 -1。

时间复杂度：O(n)

```c++
void pop_front() {
	for (int i = 2; i <= n; i++)a[i - 1] = a[i];
	n--;
}
```

**删除任意位置元素：删除位置 p 的元素。**

1: 将[p + 1,n]区间内的元素统一左移一位；

2: 元素个数 -1。

```c++
// 任意位置删除
void erase(int p) {
	for (int i = p + 1; i <= n; i++)a[i - 1] = a[i];
	n--;
}
```

### 查找元素

**按值查找：查找顺序表中数值 x 存储的位置**

策略：从前往后遍历整个顺序表，判断遍历到的元素是否等于 x。

时间复杂度：O(n)

```c++
// 按值查找
int find(int x) {
	for (int i = 1; i <= n; i++) {
		if (a[i] == x)return i;
	}
	return 0;
}
```

**按位查找：返回顺序表中第 p 位的元素**

时间复杂度：O(1)

```c++
// 按位查找
int at(int p) {
	return a[p];
}
```

### 修改元素

**修改元素：修改顺序表中第 p 位的元素为 x**

时间复杂度：O(1)

```c++
// 修改元素
void change(int p, int x) {
    a[p] = x;
}
```

### 清空顺序表

**清空顺序表：将顺序表置空**

时间复杂度：O(1)

```c++
// 清空顺序表
void clear() {
    n = 0;
}
```

::: warning 注意

要注意，我们直接实现的简单形式的时间复杂度是 O(1)。

但是，严谨的方式应该是 O(n)。

:::

### 封装静态顺序表

利用 C++中的结构体和类把我们实现的顺序表封装起来，就能简化操作，使代码的复用率大大提升。

```c++
class SQList {
	int a[N];
	int n;
public:
	// 尾插
	void push_back(int x) {
		a[++n] = x;
	}
	// 打印
	void print() {
		for (int i = 1; i <= n; i++)cout << a[i] << " ";
		cout << endl;
	}
	// ...
}
```

## 链表

### 链表的定义

- 链表：用**链式存储**实现的线性表。

- 带头链表：链表中第一个结点不存放数据元素，只存放下一个结点的指针。插入和删除操作更方便。

- 双向链表：每个结点除了存放数据元素外，还存放两个指针，分别指向该结点的前一个结点和后一个结点。方便找到前驱结点。

- 循环链表：最后一个结点的指针域指向头结点。从任意结点开始都能遍历整个链表。

链表的实现方式分为**动态实现**和**静态实现**两种。

- 动态实现是通过 new 申请结点，然后通过 delete 释放结点的形式构造链表。这种实现方式最能体现链表的特性；

- 静态实现是利用两个数组配合来模拟链表。运行速度很快，在算法竞赛中会经常使用到。

### 单链表的静态实现

要求：**两个足够大的数组**，**两个变量**

- 其中一个数组 elem 存储数据，充当数据域；

- 另一个数组 next 存储下一个结点的下标，充当指针域。

- 一个变量 h 标记头结点的下标；

- 另一个变量 id 标记新来结点的存储位置。

**定义、创建、初始化**

```c++
const int N = 1e5 + 10;

int e[N], ne[N], h, id;
```

**头插**

> 这是链表中最常用也是使用最多的操作。

1: 先把 x 放在一个格子里面；

2: x 的右指针指向哨兵位的后继

3: 哨兵位的右指针指向 x。

时间复杂度：O(1)

```c++
// 头插
void push_front(int x) {
	id++;
	e[id] = x;
	ne[id] = ne[h];
	ne[h] = id;
}
```

**遍历链表**

时间复杂度：O(n)

```c++
#include<iostream>
using namespace std;

const int N = 1e5 + 10;

int e[N], ne[N], h, id;

// 头插
void push_front(int x) {
	id++;
	e[id] = x;
	ne[id] = ne[h];
	ne[h] = id;
}

// 遍历链表
void print() {
	// 定义一个指针从头结点开始
	// 通过 ne 数组逐渐向后移动
	// 知道遇到空指针
	for (int i = ne[h]; i; i = ne[i])cout << e[i] << " ";
	cout << endl;
}


int main() {
	for (int i = 1; i <= 5; i++) {
		push_front(i);
		print();
	}
}
```

**按值查找**

解法一：遍历整个链表即可。时间复杂度：O(n)

解法二：如果存储的值数据范围不大，且无重复值，可以使用哈希表优化。时间复杂度：O(1)

::: code-group

```c++ [解法1]
// 遍历整个链表
int find(int x) {
	for (int i = ne[h]; i; i = ne[i])if (e[i] == x)return i;
	return 0;
}
```

```c++ [解法2]
// 用哈希表优化
int mp[N]; // mp[i] 表示 i 这个元素存放的位置

void push_front(int x) {
	id++;
	e[id] = x;
	mp[x] = id;// 标记 x 存储的位置
	ne[id] = ne[h];
	ne[h] = id;
}

int find(int x) {
	return mp[x];
}
```

:::

**在任意（存储）位置之后插入元素**

时间复杂度：O(1)

```c++
void insert(int p, int x) {
	id++;
	e[id] = x;
	mp[x] = id;// 标记 x 存储的位置
	ne[id] = ne[p];
	ne[p] = id;
}
```

::: warning 警告注意

这里的 p 是存储位置，不是元素，也不是链表位置。

:::

**删除任意（存储）位置之后的元素**

时间复杂度：O(1)

```c++
void erase(int p) {
	if (ne[p]) { // 当 p 不是最后一个元素的时候
		mp[e[ne[p]]] = 0; // 把标记清空
		ne[p] = ne[ne[p]];
	}
}
```

### 双向链表的静态实现
