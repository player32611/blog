# 数据结构

::: danger 警告
该页面尚未完工!
:::

## 目录

[[toc]]

## 顺序表和 vector

### 线性表与顺序表的概念

线性表是 n 个具有相同特性的数据元素的有序序列。线性表的顺序存储就是顺序表。

### 顺序表的实现方式

按照数组的申请方式，有以下两种实现方式：

- 数组采用静态分配，此时的顺序表称为静态顺序表。就是直接向内存申请一大块连续的区域，然后将需要存放的数组放在这一大块连续的区域上。

- 数组采用动态分配，此时的顺序表称为动态顺序表。就是按照需要存放的数据的数量，合理的申请大小合适的空间来存放数据。

在算法竞赛中，我们主要关心的其实是时间开销，空间上是基本够用的。因此，定义一个超大的静态数组来解决问题是完全可以接受的。

### 创建顺序表

```c++
const int N = 1e6 + 10; // 定义静态数组的最大长度

int a[N], n; // 直接创建一个大数组来实现顺序表，n 表示当前有多少个元素。
```

### 插入元素

**尾插：在顺序表表尾的后面，插入一个新元素。**

时间复杂度：O(1)

```c++
// 尾插
void push_back(int x) {
	a[++n] = x;
}
```

::: tip 提示

约定：下标为 0 的位置，不存储有效数据。也就是说数据是从 a[1] 开始存储。

:::

**头插：在顺序表表头的前面，插入一个新元素。**

1: 将[1,n]内所有元素右移一位；

2: 新的元素放在表头；

3: 元素个数 +1。

```c++
// 头插
void push_front(int x) {
	for (int i = n; i >= 1; i--) {
		a[i + 1] = a[i];
	}
	a[1] = x;
	n++;
}
```

**任意位置插入：在位置 p 处，插入一个新的元素。**

1: 将[p,n]内所有元素右移一位；

2: 把新的元素放在 p 位置上；

3: 元素个数 +1。

时间复杂度：O(n)

```c++
// 任意位置插入
void insert(int p, int x) {
	for (int i = n; i >= p; i--)a[i + 1] = a[i];
	a[p] = x;
	n++;
}
```

### 删除元素

**尾删：删除顺序表的表尾元素。**

时间复杂度：O(1)

```c++
// 尾删
void pop_back() {
	n--;
}
```

**头删：删除顺序表的表头元素。**

1: 将[2,n]区间内的元素统一左移一位；

2: 元素个数 -1。

时间复杂度：O(n)

```c++
void pop_front() {
	for (int i = 2; i <= n; i++)a[i - 1] = a[i];
	n--;
}
```

**删除任意位置元素：删除位置 p 的元素。**

1: 将[p + 1,n]区间内的元素统一左移一位；

2: 元素个数 -1。

```c++
// 任意位置删除
void erase(int p) {
	for (int i = p + 1; i <= n; i++)a[i - 1] = a[i];
	n--;
}
```

### 查找元素

**按值查找：查找顺序表中数值 x 存储的位置**

策略：从前往后遍历整个顺序表，判断遍历到的元素是否等于 x。

时间复杂度：O(n)

```c++
// 按值查找
int find(int x) {
	for (int i = 1; i <= n; i++) {
		if (a[i] == x)return i;
	}
	return 0;
}
```

**按位查找：返回顺序表中第 p 位的元素**

时间复杂度：O(1)

```c++
// 按位查找
int at(int p) {
	return a[p];
}
```

### 修改元素

**修改元素：修改顺序表中第 p 位的元素为 x**

时间复杂度：O(1)

```c++
// 修改元素
void change(int p, int x) {
    a[p] = x;
}
```

### 清空顺序表

**清空顺序表：将顺序表置空**

时间复杂度：O(1)

```c++
// 清空顺序表
void clear() {
    n = 0;
}
```

::: warning 注意

要注意，我们直接实现的简单形式的时间复杂度是 O(1)。

但是，严谨的方式应该是 O(n)。

:::

### 封装静态顺序表
